# 设计模式
## 1. 基础设计模式(Simple)
- 单例模式(Single): ``保证一个类只有一个实例，并提供一个访问它的全局访问点``
- 工厂模式(Factory): ``一个类通过本身的静态方法来，实例化一个类并返回一个实例对象``
- 注册模式(Register): ``已经创建好的对象，挂在到某个全局可以使用的数组上，在需要使用的时候，直接从该数组上获取即可。将对象注册到全局的树上。任何地方直接去访问``
## 2.适配器模式(Adapter)
``可以将截然不同的函数接口封装成统一的API``

例如: PHP的数据库操作有mysql，mysqli，pdo3种，可以用适配器模式统一成一致。类似的场景还有cache适配器，将memcache，redis，file，apc等不同的缓存函数，统一成一致
## 3.策略模式(Strategy)
``策略模式，将一组特定的行为和算法封装成类，以适应某些特定的上下文环境，这种模式就是策略模式``

例如: 实际应用举例，假如一个电商网站系统，针对男性女性用户要各自跳转到不同的商品类目，并且所有广告位展示不同的广告

除此以外: 使用策略模式可以实现loc，依赖倒置、控制反转
## 4.观察者模式（Observer）
``观察者模式，当一个对象状态发生改变时，依赖它的对象全部会收到通知，并自动更新``

场景： 一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件主体的代码

### 观察者模式实现了低耦合，非侵入式的通知与更新机制
## 5.原型模式(Prototype)
``与工厂模式作用类似，都是用来创建对象``

与工厂模式的实现不同，原型模式是先创建好一个原型对象，然后通过clone原型对象来创建新的对象。这样就免去了类创建时重复的初始化操作

原型模式适用于大对象的创建。创建一个大对象需要很大的开销，如果每次new就会消耗很大，原型模式仅需内存拷贝即可
## 6.装饰器模式（Decorator）
``装饰器模式，可以动态地添加修改类的功能,允许向一个现有的对象添加新的功能，同时又不改变其结构``

一个类提供了一项功能，如果要在修改并添加额外的功能，传统的编程模式，需要写一个子类继承它，并重新实现类的方法

使用装饰器模式，仅需在运行时添加一个装饰器对象即可实现，可以实现最大的灵活性
## 7.迭代器模式 (Iterator)
``迭代器模式，在不需要了解内部实现的前提下，遍历一个聚合对象的内部元素``

相比于传统的编程模式，迭代器模式可以隐藏遍历元素的所需的操作。
## 8.代理模式（Proxy）
``在客户端与实体之间建立一个代理对象，客户端对实体进行操作全部委派给代理对象，隐藏实体的具体实现细节.``

Proxy还可以与业务代码分离，部署到另外的服务器。业务代码中通过RPC来委派任务.
## 持续翻新.......
